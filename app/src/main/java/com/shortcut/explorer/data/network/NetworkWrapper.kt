package com.shortcut.explorer.data.network

import com.shortcut.explorer.data.network.model.OnFail
import com.shortcut.explorer.data.network.model.OnSuccess
import com.shortcut.explorer.data.network.model.Resource
import com.shortcut.explorer.data.network.model.ServerResponse
import kotlinx.coroutines.yield
import org.json.JSONException
import retrofit2.HttpException
import retrofit2.Response
import java.net.ConnectException
import java.net.SocketTimeoutException
import java.net.UnknownHostException

/**
 * Wraps network call and return corresponding [Resource] depending on final requested response.
 * An error [Resource] is generated by [onFailed] or ongoing try-catch if the network request is
 * failed.
 */
class NetworkWrapper{


    suspend fun <T> fetch (call: suspend () -> Response<ServerResponse<T>>,
                           onSuccess: OnSuccess<T>,
                           onFail: OnFail
    ) : Resource<ServerResponse<T>> {
        /**
         * yield()
         * Cancel the job if request was cancelled already
         */
        yield()

        return try {
            val result = run(call)
            yield()

            if (result.isSuccessful)
                onSucceed(result,onSuccess)

            else
                onFailed(result.code(), onFail)

        } catch (e: HttpException) {
            e.printStackTrace()
            Resource.error(errorCode = e.code())

        } catch (e: ConnectException) {
            e.printStackTrace()
            Resource.error(errorCode = CONNECT_EXCEPTION)

        } catch (e: SocketTimeoutException) {
            e.printStackTrace()
            Resource.error(errorCode =  SOCKET_TIME_OUT_EXCEPTION)

        } catch (e: UnknownHostException) {
            e.printStackTrace()
            Resource.error(errorCode = UNKNOWN_HOST_EXCEPTION)

        } catch (e: Exception) {
            e.printStackTrace()
            Resource.error(errorCode = EXCEPTION)
        }
    }

    private suspend fun <T> onSucceed(body: Response<ServerResponse<T>>, onSuccess: OnSuccess<T>): Resource<ServerResponse<T>>{
        onSuccess(body.body())
        return Resource.success(body.body())
    }

    private suspend fun <T> onFailed(code: Int, onFail: OnFail): Resource<ServerResponse<T>>{
        return try {
            onFail.invoke("msg",code)
            Resource.error( "msg", errorCode = code)

        }catch (exception: JSONException){
            Resource.error(exception.localizedMessage)
        }
    }

    companion object {
        const val CONNECT_EXCEPTION = 600           /** It means there is no internet connection around. */
        const val SOCKET_TIME_OUT_EXCEPTION = 601   /** No internet connection or poor connection quality */
        const val UNKNOWN_HOST_EXCEPTION = 602      /** Probably a dns issue or wrong host address */
        const val EXCEPTION = 603                   /** Something that should be investigated */
    }
}
